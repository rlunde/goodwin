======================================
Background
======================================

I tried to think of a good sidekick from literature or film that
reminded me of what I wanted for this, and came up with Archie
Goodwin, Nero Wolfe's sidekick. In the Nero Wolfe books by Rex
Stout, Archie Goodwin is a wise-cracking assistant who does a lot
of things, but who needs the brilliant (yet stay-at-home) detective
to actually figure things out. In this respect the users of this
app play the role of Nero.

The basic idea is to make a code generator, simplifier, improver,
that has a conversation with you, and can read/parse code and
generate or regenerate bits of it. Rather than a typical code
generator, which is done once at the beginning of the project, by
filling out a form (or equivalent), this would ask questions, and
get more specifics and the models, APIs, etc., before generating
the first code, and would leave markers in the code (as comments)
to guide later parsing and automated changes.

General Guidelines

1) make the simplest possible thing just to get started
  a) start off with tiny little code generators
  b) make a module that asks questions and fills in a config struct
  c) save and load config
  d) brainstorm a list of simple code generators and pick those that are 
     original and fun
2) try to make it fun, and funny -- make it a wiseass like 
   Archie Goodwin in the books
3) make a list of all the most popular code generators (e.g. in Rails), and see how
   they work. Look for things that can parse and ge-generate portions of code.
4) decide on an architecture -- I think I could get hung up worrying about 
   deployment issues, but since (initially at least) this is for developers, 
   the client piece should be transparent, and anything destructive should be 
   very carefully done and verified.
5) I'm thinking of a client/server architecture, with the server written for 
   speed, simplicity, and efficiency, and the client written for simplicity 
   and transparency.

In addition to code generation, I'd like if it just helped people figure out how to
use tools. Git is a great place to start. There are a whole lot of options
to git and different ways of using it, and most of the confusion could
probably be cleared up by asking a few questions.

Writing code or explaining code probably falls into the same category. A user
may want to know what a closure is, and when to use one, or may want syntax
help just making an anonymous function, or may want a confusing bit of code
explained.

I think this first thing will be a handful:
a) make a json format to describe a project to be code generated
b) make a code generator
c) make the code generator take the json format
d) make an interactive bot that helps build up the json file

Of course, later on, it should be a lot more feature rich, but that
seems like a good short term strategy.

Lately I've tried using a fair number of javascript code generators, and while
some of them do a really great job of generating a project that covers all the
bases, to a great degree they're all examples of what I consider the absolute
worst approach to software development: start with a framework that includes
(literally) *megabytes of source code* and then have a "build" step to generate
a light-enough version for browsers to use, but have the "built" stuff be
incomprehensible and (realistically) uneditable.

Meanwhile, the tutorial sites for react, angular, etc. all want to show you how
a few JS includes from a CDN will pull in their framework/libraries, and then
you can make your "hello world" example in a handful of lines.

I want to have a code generator that goes beyond hello world, but generates
something that will actually run in a browser but be editable by hand. I want
an assistant, that can help re-generate portions of code, or refactor code, or
explain code, not a thing that just poops out something that's too big to 
understand in a dev environment that makes stuff that's too munged up to
understand in the browser.

I don't want to stop people from using the output in a big project with 87
million bells and whistles, I just don't want to require it.

So what's the first step towards that?

Start by writing up a high level architecture / design.

Also, I have a few other sample projects that I'm doing just to learn things -- this
is a perfect opportunity to take a step back and make this project be the thing
that generates (some of) the code for those. That way I have some very simple
real world examples to work with and still make progress on those other things.
Maybe.

This is an example todo stack as I imagine it might be represented in funtodone (see
that project) for goodwin.

Overall ToDo:

0: create a MVP release of goodwin
1: define what features are critical (vision, docs, code, examples, websites)
1: make a first example of client, server, and working demo
2: get a D3 conversational code generator working for a limited subset of D3
3: make a D3 code generator that takes a JSON description and produces a D3 example
3: make a simple node client that just 
  a: makes a directory for D3 project sample descriptions
  b: collects info for a D3 sample and outputs JSON description
4: include description in every JSON element (since we can't have comments)
4: make an example JSON format D3 sample project description

Client ToDo:

  Layout:

  [x] default to a larger window (if can do without extending beyond screen)
  [x] put input box on the bottom of the chatinterface
  [x] make chatinterface and forminterface take up 100% height of 
      enclosing div (use flexbox)

  Interaction:

  If I use react, I'll also need to use react-bootstrap:
    [ ] https://react-bootstrap.github.io/components.html#page-layout

  There's an explanation here for why you need react-bootstrap (it's just
  for the javascript/DOM interactions, not the CSS):
  https://stackoverflow.com/questions/38015494/can-we-use-pure-bootstrap-with-react-js

  
Next Steps:
  [ ] design the JSON that will be passed to the server to generate the D3 samples
  [ ] design the initial NLP-ish parsing to be done by the chat interface
  [ ] design the initial state bundle that will be used by the client
  [ ] pop up the form interface given the right chat command
  [ ] fill in the form interface for bar chart options
  [ ] generate the D3 sample, and say where it is (docker mount)
  

