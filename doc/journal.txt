Before November 2017:
==================================================================

I evaluated using python or ruby to do the CLI version, but
since I want to eventually have an electron-based client, it
made sense to stick with node.

There's a cool article on making a python CLI here, though:
https://stormpath.com/blog/building-simple-cli-interfaces-in-python

The node article I'm starting with is:
https://developer.atlassian.com/blog/2015/11/scripting-with-node/

If I move on to a node environment with automatic babel compilation
(which seems like a good thing to try), I might start here:

https://github.com/babel/example-node-server


==================================================================
November 9, 2017:
==================================================================
I had fun working on the node CLI for Goodwin, but discovered
something interesting: a chat interface is a good way to do some
things, but not a good way to do *everything*. Basically, once
you want the user to do something very specific, such as pick
an item from a list, fill in values needed to generate code, etc.,
they're better off interacting with a form.

Even the chat interface is probably best done in a way that resembles
what you see in slack or hipchat. My current idea is to have the
chat input at the bottom, and use the right hand side to collect 
info using dynamic form elements.

I'll start by trying to lay out something like that.


==================================================================
November 14, 2017:
==================================================================
I spent a couple of days on sideauth (just to avoid forgetting what
I was doing there). Now I want to:
a) move the files from under cli client (giving up on a separate CLI)
b) make an outline of the basic electron app layout


==================================================================
Friday, November 17, 2017
==================================================================

I'd like to try to do a little test-first development on this project,
but I'm not sure how to begin. I think maybe I should have two top
levels -- one a regular web app, and one an electron app. The regular 
web app could use node/express, perhaps.

I think that might just double the effort and magnify the complexity
though. I'll start by looking at spectron:
https://github.com/electron/spectron

==================================================================
Sunday, November 19, 2017
==================================================================

I'm trying to get a simple layout working. I think I'm stuck in my same
old rut, trying to get two divs to line up next to each other, each of
which takes up a fixed percentage of the containing box. 

TODO: add "simple" CSS code generation to what goodwin generates!

==================================================================
Monday, November 20, 2017
==================================================================

Finally got the two divs to line up side by side. Honestly! Why on
earth is that so hard? Most of the stupid StackOverflow questions I found
on it were "closed as duplicates", and most of the remaining ones were wrong.
I think the people who "close as duplicates" without saying duplicates
of *what* are ... well, "jerks" is about the most polite term I can think of.

==================================================================
Tuesday, November 21, 2017
==================================================================

There's at least one very annoying layout issue remaining, which is that the
inputtext box for the chat interface sticks out into the form div. 

OK, figured that out (needed to add bootstrap classes to the divs and the
textarea), but there are still a few layout things to figure out. I'll add them
to a todo file.

==================================================================
Wednesday, November 22, 2017
==================================================================

I have a little script that I use to pick a random project and a random kind
of thing to do (heavily weighted towards goodwin). Today's task is documentation
for goodwin. I think I'll start by going through each file under the doc 
directory, and just doing minor editing and writing a todo list for it. Then
I'll brainstorm a list of other documentation I need. I guess I should move
all my todo files and this journal under doc as well, so I don't have to hunt
all over the place for it.

==================================================================
Thursday, November 23, 2017
==================================================================

Today's task is "goodwin/design". I can take that to mean either
layout/UI/UX, or code design, or both.

I want to try making the client with React, so I'll start by thinking
about:
1) what should the chat dialog look like?
2) how should chat interaction work?
3) how should form interaction work?

See chat-notes.txt and form-notes.txt for starts at those


==================================================================
Tuesday, November 28, 2017
==================================================================

I started taking a class on CodeSchool on CSS Flexbox, which I 
suddenly realized is exactly what I need for laying out the
main content of the client app (aside from the navbar and the
footer).

 If I use react, I'll also need to use react-bootstrap I assume:
https://react-bootstrap.github.io/components.html#page-layout

There's an explanation here for why you need react-bootstrap (it's just
for the javascript/DOM interactions, not the CSS):
https://stackoverflow.com/questions/38015494/can-we-use-pure-bootstrap-with-react-js

==================================================================
Friday, December 1, 2017
==================================================================

Today's task is testing. Last time I looked at it I installed spectron
and mocha, and got a first test running (npm test) that just checks to
make sure the application launches.

For individual unit tests, I should be able to just use mocha directly,
I'd guess, without the spectron stuff to launch an application. Of course,
I don't really have anything to test yet.

Also, if I really do integrate react with electron (which makes sense
to try, at least), then I'd probably be better off using jest than mocha.

Hmm, after spending an hour or so poking around, it seems there are
some big challenges with using jest with spectron/electron and react.
I may be asking for trouble.

I think what I'll do is try using mocha with enzyme to test react,
and see if that works from inside spectron. If I get in trouble,
I think the first thing to do is just abandon react for this project,
and try to stick to a more conventional approach to making and
testing electron apps.

See:
https://github.com/airbnb/enzyme
https://medium.com/@kayodeniyi/setting-up-tests-for-react-using-mocha-expect-and-enzyme-8f53af96fe7e
https://github.com/electron/spectron
https://medium.com/@Agro/developing-desktop-applications-with-electron-and-react-40d117d97564

I tried starting with:
npm install --save-dev mocha expect enzyme jsdom react-addons-test-utils

I also installed react, react-dom, react-bootstrap

==================================================================
Thursday, December 7, 2017
==================================================================

Today's task is documentation.

One thing in the back of my mind for some time now is that I should write the
plan for goodwin in the form of a story. Probably, I'd want to start off with
a person using it to get something minimal done, and then have a new chapter
with a slightly smarter and more helpful app each time, until eventually the
app is indistinguishable from an actual human assistant (in terms of what it says).

Of course, that wouldn't be a very exciting story. I'll need some conflict
and suspense and danger. I'm going to try to make an outline.

==================================================================
Friday, December 8, 2017
==================================================================

Today's task is to simplify goodwin.

I think all those links I found before are basically obsolete by
now. If I seriously want to do an electron app with react and redux (and
it still seems to me that I should at least give it a try) then I
should restart from this boilerplate:

https://github.com/chentsulin/electron-react-boilerplate

So first move all the code out of the way, then follow the
directions there. If I can't get it working, delete all that, 
and start over with this code, and just get rid of react/redux.

Here goes nothing...

It mostly worked. I get this error from "npm run dev" after everything
is installed:

errno: -13,
  code: 'EACCES',
  syscall: 'open',
  path: '/Users/ron/Library/Application Support/Electron/extensions/fmkadmapgofadopljbjfkapdkoienihi/build/inject.js' }
Failed to read content scripts { Error: EACCES: permission denied, open '/Users/ron/Library/Application Support/Electron/extensions/fmkadmapgofadopljbjfkapdkoienihi/build/inject.js'
    at Object.fs.openSync (fs.js:584:18)
    at Object.module.(anonymous function) [as openSync] (ELECTRON_ASAR.js:173:20)
    at Object.fs.readFileSync (fs.js:491:33)
    ...

I don't know why it put Electron under my Application Support folder, but the "build" directory under that weird
path had 644 rather than 755 permissions.

After changing those permissions, I still get this warning:

> electron-react-boilerplate@0.12.0 start-main-dev /Users/ron/Projects/goodwin/client
> cross-env HOT=1 NODE_ENV=development electron -r babel-register ./app/main.dev

(node:54719) DeprecationWarning: Chunk.modules is deprecated. Use Chunk.getNumberOfModules/mapModules/forEachModule/containsModule instead.
    at /Users/ron/Projects/goodwin/client/node_modules/extract-text-webpack-plugin/index.js:271:24
    at /Users/ron/Projects/goodwin/client/node_modules/async/dist/async.js:3060:16
    at eachOfArrayLike (/Users/ron/Projects/goodwin/client/node_modules/async/dist/async.js:1003:9)
    at eachOf (/Users/ron/Projects/goodwin/client/node_modules/async/dist/async.js:1051:5)
    at Object.eachLimit (/Users/ron/Projects/goodwin/client/node_modules/async/dist/async.js:3122:5)
    at ExtractTextPlugin.<anonymous> (/Users/ron/Projects/goodwin/client/node_modules/extract-text-webpack-plugin/index.js:268:10)
    at Compilation.applyPluginsAsyncSeries (/Users/ron/Projects/goodwin/client/node_modules/tapable/lib/Tapable.js:206:13)
    at Compilation.seal (/Users/ron/Projects/goodwin/client/node_modules/webpack/lib/Compilation.js:596:8)
    at applyPluginsParallel.err (/Users/ron/Projects/goodwin/client/node_modules/webpack/lib/Compiler.js:508:17)
    at /Users/ron/Projects/goodwin/client/node_modules/tapable/lib/Tapable.js:289:11

From poking around it looks like this issue may have been fixed in a later webpack -- I tried putting 3.4.1 
in package.json instead of 3.0.0. The specific warning during yarn install may be:

warning "extract-text-webpack-plugin@2.1.2" has incorrect peer dependency "webpack@^2.2.0".

The latest extract-text-webpack-plugin is 3.0.2, so I'm trying that again, then trying yarn install again...

That seems to have fixed that error.


==================================================================
Saturday, December 9, 2017
==================================================================

Today's task is to simplify goodwin, just like yesterdays. Wow -- the universe must
really want me to simplify this! Yesterday, I just grabbed a new starting boilerplate
and fixed a couple of errors related to technical debt / decay of the boilerplate,
but didn't actually do anything on goodwin itself.

I especially didn't simplify it.

Today I just want to write down what I'm thinking about simplifying the architecture of
goodwin.

1) Use Docker
2) Server will be written in Go, use a docker bind mount to pass configuration data beyond ports
   (if any is needed), and use a volume to store the database which will persist session data and
   chat history per user.
3) Client will be written in electron/react/redux boilerplate, use a docker bind mount to pass
   in local configuration data (such as server info), use REST and/or websockets to communicate
   with the server, and use a docker volume (probably?) as the destination of generated source
   code or the code being updated/edited by goodwin.

This "should" let me easily deploy server and client, should protect the client's user
from malicious changes caused by rapid server development / insufficient safeguards, and
hopefully will be easy enough to use so that client users can copy generated source code
into their own git repos (etc.).

Now all I have to do is write it!

==================================================================
Monday, December 11, 2017
==================================================================

Today's task is design for goodwin.

I can take that many different ways. Design as in UI/UX, design as
in code, design as in database, etc. I think I've got a reasonably
good idea of what I want the UI/UX to be:

Electron-based App with:
1) a header nav bar (pinned to top of window)
2) a content area
3) a footer (pinned to bottom of window)

The navbar will be where all the menu stuff happens.

When the client starts up and the user signs in, the content area
will just have the chat interface. When the chat interface detects
something that needs form input (e.g. filling in the options for
code generation) it will slide in a panel on the right hand side,
and reformat the chat history on the left. I'm thinking it will be
an actual panel, not a modal, but we'll see.

The forms for filling in options should have default values and 
should remember user input across invocations. The user should be 
able to cancel the form at any time.

The chat interface should still work while the form is up. If there
is an action (like generate code) that the user can expect to do 
after filling in a form, the files that result should be downloadable 
as a zip, or we should just open the directory in whatever OS file
browser/finder we have. Could also launch a configured IDE or bash
shell to that directory?

Later, when goodwin does more thna just generate code, but actually
helps edit existing code, we'll have to figure out how to make
a smart plugin that talks to the goodwin server from the editor.


==================================================================
Tuesday, December 12, 2017
==================================================================

Well, my attempt to start over with this utterly failed:
https://github.com/chentsulin/electron-react-boilerplate

Too many reasons to list here, but it's another example of kitchen
sink programming. I spent *hours* trying to fix software rot that
caused spurious errors in vscode, and never succeeded entirely.
Most of the ones I couldn't figure out how to fix were due to the
use of Flow for static type checking, but basically, I want to work
on a small app to start with, not a giant app that doesn't work that
I want to fill in my small app stuff.

So I'm back to my old client. I still don't know whether it's really
worth it to add in react or not. The base electron doesn't use it,
and it complicates the hell out of testing, etc. I'll give it a few
more days before I bail on that.

The good news is, I learned some stuff! One thing I learned, is
that when Visual Studio code loses it's mind and gives errors even 
across restarts, you can cure it by just deleting the ~/.vscode 
directory.

Also, I found another interesting looking article on medium, that
has been pondering again whether electron is really necessary for
goodwin, at least at this stage.

https://medium.com/@francesco.agnoletto/i-didnt-like-create-react-app-so-i-created-my-own-boilerplate-190a7dd5d74

It's not talking about electron, just about not hiding all the magic 
configuration stuff the way create-react-app does.


==================================================================
Wednesday, December 13, 2017
==================================================================

Today's task is to simplify goodwin.

I've been thinking about what happened with the electron react boilerplate,
and have come to the conclusion that my next experiment will be to start with
the link above, and just turn goodwin into a two docker containers. One
container will be a regular web app -- probably just the client web app in 
react/redux and a lightweight web server that can read/write source code in
the docker volume -- and the other will be an app server written in go.
I'll just call from one container to the other. 

So 3 system components, with the following responsibilities:

client:
  * UI and UX
web server:
  * read/write local files
  * notice file changes (so you can edit in IDE of choice)
  * interact with app server
  * interact with client
app server:
  * do the business logic (initially just code generation)

Since both containers could be run locally, there's no need (yet)
to do any account creation, auth, login, password management, etc.
Even in the longer term, web server<->app server credentials might
be best done via an API key rather than an account.

The web server could be in node/express, but I think I'll start 
off at least writing both web services in go.

I do want the SPA web page to be responsive, so you could run
the containers anywhere and run the web app on a tablet in a pinch,
since code generation won't be the only thing goodwin does (after all,
the chat interface is the most important part), but there's no 
reason it has to be an electron client -- or anything other than
a web app.

==================================================================
Wednesday, December 20, 2017
==================================================================

I added the example Jest test on the 15th. Today I want to just
plan out some next steps for doing this TDD.

TDD Next Steps:
  simpleclient:
    [ ] main page should have a nav bar
    [ ] main page should have a footer
    [ ] main page should have a chat panel
  web server:
    [ ] health check api should work
    [ ] version API should work
    [ ] chat APIs should work
    [ ] template/form APIs should work
  app server:
    [ ] health check api should work
    [ ] version API should work
    [ ] chat APIs should work
    [ ] command APIs should work

  Now I have to figure out what some of those actually mean.
  I assume that the web api is just there to interact with the
  client, providing help for presentation and a (mostly) pass-through
  interface to the app server.

  Information needed to fill in a command might be sent back to
  the web service from the app service, which could then turn that
  into regular (non-React) forms. Or (better) let the React javascript
  dynamically build forms based on API response.

  That means that the client can't be super dynamic, unless the
  web API is filling in templates that come from the app server.
  I think that's complicated enough that there's no reason to start
  off with it, but I just have to remember that in the long term,
  that's the direction I want to go. So the Web service should download 
  the latest JSX files from the app server on startup, and build them?
  Hmm. Better not. Better keep the templates just data, and make the
  React code smart enough to build up whatever form is needed from
  a JSON description.
  

==================================================================
Sunday, December 24, 2017
==================================================================

'twas the night before Christmas...

My goal for this week is to get as much of the basic UI working
as I can. I'll start off with a basic CSS layout, probably based
on either flexbox or grid. If I use grid, I probably don't need to
use react-bootstrap as much (or maybe at all).

Here's the order to do UI stuff:

[x] get the overall page structure working
[ ] get the form interface working as a modal
[ ] get the chat interface working

After that, I want to work out packaging and running with Docker,
with a volume mounted that I can write out source code to, and a 
file of configuration options.

Then I'll work on getting D3 bar chart generation working, as I 
started to do in the CLI interface.

==================================================================
Tuesday, December 26, 2017
==================================================================

I think this is "boxing day" in some parts of the world. Probably 
(just guessing) that isn't "casting primitive types into objects" day.

I realized that the order of the next pieces should really be:

[ ] get the chat interface working
[ ] get the form interface working as a modal

...since the chat interface should cause the form interface to display
when needed. That is, when you say you want to generate a sample D3
bar chart, it should bring up the form to let you fill in parameters.

The chat interface should have the text input area at the bottom, and 
however many previous things (from history) there are should stack 
above it, left justified and yellow for user input, and right justified 
and blue for goodwin. All colors should be configurable eventually,
but I doubt I need to obsess about that now.

Each of the chat boxes should have a tiny timestamp, and it should
start up with the previous screenful. At the very top there should be
a gadget to let you get more history (if available) or to search
history (eventually). You should also be able to delete things from
the history, since this is just a conversation with goodwin, not
between two people.

So:
  <div class="chatHistory">
    <div class="chatHistoryItem">text</div>
  </div>
  <div class="chatInput"></div>

I think chatInput should be a wrapper around a styled inputText box,
if possible, rather than turning a custom control into an inputText box.
I've read that accessibility and stuff tend to always get done wrong if
you try to roll your own. I guess the first thing I'll do is look for
some examples.

This looks like a good starting place:
https://codepen.io/thatdevguy/pen/HbKCf

==================================================================
Friday, December 29, 2017
==================================================================

Tonight I started looking at React router. Nothing accomplished
beyond some research.

==================================================================
Sunday, December 31, 2017
==================================================================

The hard part about doing a project (or multiple projects, if you're
a goofball like I am) is not getting hung up on layout while still 
making it look good enough to avoid turning people off the instant
they see it.

I think the layout is OK for now (not counting authentication, since 
I can postpone that for a long time, given the docker strategy). Not 
that I don't need to make it a lot nicer, but I can do that as part 
of getting a "spike" of functionality done.


==================================================================
Wednesday, January 3, 2018
==================================================================

JSON that is formatted by the client to tell the server what to generate 
should be extensible. Design it around GraphQL? Not yet. Let's start
with the simplest thing that could possibly work.

{
  "command":"generate",
  "type":"D3",
  "parameters":{
    ...
  },
  "location": {
    ...stuff about directory / file names ...
  }
}

==================================================================
Thursday, January 4, 2018
==================================================================

I'm feeling really crummy tonight, but I thought I'd try to at least
think about this. Let's think about testing the format tonight.

I think all I have to do is write a test that will fail because there
is no JSON file.

==================================================================
Saturday, January 6, 2018
==================================================================

Later on, I'll want to have a lot of state (including history from 
previous sessions) tucked away in mongodb (or something) on the server
side, but for right now, I'll just try collecting all the state I
need on the client side, and sending just what the server needs to 
generate a D3 sample.

Continuing on TDD of D3 sample generation...

Converted the golang server to use Gorilla Mux. Got the first test
working. Added a stubbed out handler for generating D3 sample code.

==================================================================
Sunday, January 14, 2018
==================================================================

I want to break down MVP into:

1) a definition - a short paragraph of why, who, what, when
2) a list of stories - features expressed as user stories
3) for each story, a list of tasks

Once that's done, I want to move everything but what is on path 
to that into a backlog folder.

First, to get the updated client built:

$ cd simpleclient
$ yarn
$ yarn start
$ open http://localhost:3000


==================================================================
Monday, January 15, 2018
==================================================================

It's too late to do much of anything tonight already. I'll try to just 
expand my definition of MVP a bit, and move something to a backlog folder.

==================================================================
Sunday, January 21, 2018
==================================================================

I thought I'd try to get back to TDD today, so that means both
the go/server side and the js/simpleclient side

I started using jest for JS testing the last time I looked at this.

https://facebook.github.io/jest/docs/en/getting-started.html
To run the tests, do:

$ npm test
or
$ yarn test

I'd also like to try airbnb's enzyme. Does it work with jest?
https://github.com/airbnb/enzyme

Yes! https://github.com/airbnb/enzyme/blob/master/docs/guides/jest.md

I installed enzyme with:
$ npm i --save-dev enzyme enzyme-adapter-react-16

They suggest using yarn for jest-enzyme. That starts with:

$ yarn add jest-enzyme --dev

Then I added this to package.json:

"jest": {
    "setupTestFrameworkScriptFile": "./node_modules/jest-enzyme/lib/index.js",
      "unmockedModulePathPatterns": [
      "react",
      "enzyme",
      "jest-enzyme"
    ]
  },

That's all I have time for tonight. I should start off next time by seeing what this
sample project does, and trying to get it going with that:

https://github.com/vjwilson/enzyme-example-jest/blob/master/src/__tests__/Foo-test.js

==================================================================
Wednesday, January 24, 2018
==================================================================

Tonight's randomly selected task is to simplify goodwin, rather than test.

I think the best way to do that is just to divide and conquer.

Bar chart:
  Collect input:
    Collect data source type:
    Make sample
  Generate sample code
Dockerize it

==================================================================
Thursday, January 25, 2018
==================================================================

To start with a test, I would make a bar chart sample, then make the input
to use with a code generator, then make a test that the sample is identical,
then write the code to do it.

I probably don't want to make a super-fragile test, which would happen if 
I just checked for an exact string match. But if I don't do that, I'd need to 
do some sort of parsing of the generated code, or at least have some regexes that
match various parts.

In the long run, I want to do code regeneration, so parsing code is going to 
be required. 

I guess a compromise is to start by just looking for significant bits.

I'll make a sample under samples/barchart_sample1.

==================================================================
Saturday, January 27, 2018
==================================================================

I'm using VS Code with this project, and had just spent a few minutes
working on this when it told me I had a corrupted VS Code. When I re-installed
it and restarted it, the stuff I'd written was missing. This makes me nervous.

Tonight: documentation
Tasks:
1) review what I have already, make a list/index
2) make a list of the documentation I'd like to have
3) make a plan (goals, stories, tasks) to get there, with a simple spreadsheet
4) use storytelling and humor to make the docs interesting to read

==================================================================
Sunday, January 28, 2018
==================================================================

Tonight: design 

One of the things that Design First thinking is supposed to accomplish,
it to address the real problems to be solved, rather than get all snarled
up in features and functionality that at the end of the day has nothing
to do with what the thing was ultimately about.

I think what I need is a manifesto. I don't even really know what that
means yet, but that's something I think might help me figure out how to 
get this thing done.

==================================================================
Wednesday, January 31, 2018
==================================================================

Tonight: simplify

Let's get back to a single first feature:

Bar chart:
  Collect input:
    Collect data source type:

1) trigger bar chart form
  a) collect input from the chat interface
    i) look up react/redux input handler example
      - I just added className "chat-input" to the input field
    ii) watch Stephen Grider's tutorial again, take notes
  b) display the form as a modal
2) collect data source type (csv, tsv (tab separated), dsv (delimeter separated))
3) collect data source file name (or let them choose an existing sample)

This looks like an interesting tutorial:
http://blog.isquaredsoftware.com/2016/10/practical-redux-part-0-introduction/

For now though, I'm too tired to make progress on this (little sleep for more than 
a week due to home damage / reconstruction), so I'll go look at SG's tutorial for 
a few minutes and call it a day.

==================================================================
Thursday, February 1, 2018
==================================================================

I'm so tired tonight that I'm sitting here, stunned, like a carp.

I've had around 4 hours of sleep a night for the past...forever.

So just whining tonight is all I can muster.

==================================================================
Friday, February 2, 2018
==================================================================

Tonight: coding

I think if I'm going to use a modal for the form, I'll just get rid of the sidebar.

I did that, and got rid of a little bit of the stuff that was just there to see what formatting looked like.


==================================================================
Saturday, February 3, 2018
==================================================================

Just working on long term vision and big picture stuff tonight. How do you make
a super useful developer tool? Start with a (very) slightly less useful developer
tool and use it to help you make an improved version.

==================================================================
Sunday, February 4, 2018
==================================================================

I'm going through Stephen Grider's Advanced React and Redux on Udemy
again, and taking notes. I need to translate the testing he's doing
to use Jest with Enzyme.

https://github.com/vjwilson/enzyme-example-jest/

I ended up having to install more things and fix a bunch of issues
from the sample test I copied:

npm i --save-dev enzyme enzyme-adapter-react-16
npm i --save-dev jest-cli
npm i --save-dev jest-enzyme

I added a file named "assetTransformer.js" and configured jest in package.json as in:
https://facebook.github.io/jest/docs/en/webpack.html
Then fixed a problem by using a solution similar to:
https://stackoverflow.com/questions/46435558/could-not-find-declaration-file-for-enzyme-adapter-react-16

That got me (finally) to a point where I got an actual test failure! Yay!

==================================================================
Wednesday, February 7, 2018
==================================================================

I had a minor epiphany just now, which is all I have time for tonight:

If my main goal for goodwin is that it is "an evolutionary developer's 
assistant that also helps to make itself better", the first thing I should
work on is not D3 code generation, but something that could actually 
be of use in making goodwin better. (Maybe that's a "duh!" but it just
hit me.)

So I'm going to go off and think of baby steps that might align with that.
